%module foreach_0

  %prototype foreach_0
    %persistent .state nil
    %persistent .exitstack []
    %persistent .states [
      { "idle" { "enter" λidleenter "handler" λidlehandler "exit" λidleexit } }
      { "generating" { "enter" λgeneratingenter "handler" λgeneratinghandler "exit" λgeneratingexit } }
      { "generating" { "enter" λgeneratingenter "handler" λgeneratinghandler "exit" λgeneratingexit } }
    ]
    %persistent .handler λforeach_0_statehandler
    %persistent .outputqueue []
    %persistent .env {}

    %persistent .files []

    %constructor
      %call .states.idle.λenter
    %endconstructor

  %endprototype foreach_0

  %function λforeach_0_statehandler ({«self» «message»})
    %switch «self».state
      %case 'idle'
	%call «self».states.idle.handler ({«self» «message»})
      %endcase 'idle'
      %case 'generating'
	%call «self».states.generating.handler ({«self» «message»})
      %endcase 'generating'
      %case 'blocked'
	%call «self».states.blocked.handler ({«self» «message»})
      %endcase 'blocked'
    %endswitch «self».state
  %endfunction λforeach_0_statehandler

  %function λfidleenter («args.self»)
    %call «self».exitstack.λpush («self».states.idle.exit)
    %overwrite «self».files ❮list files '/Users/tarvydas/temp/ps/@book-Hamburger Workbench - A Frivolous Introduction to Ohm-JS'❯
  %endfunction λfidleenter
  %function λfidleexit () %endfunction «fidleexit»
  %function λfidlehandler ({«self» «message»})
    %switch «message».etag
      %case 'env'
	%overwrite «env» «message».data
      %endcase 'env'
      %case 'begin'
	%mapλ «self».exitstack
	%overwrite «state» 'generating'
	%call λgeneratingenter ()
      %endcase 'begin'
    %endswitch «message».etag
  %endfunction λfidlemessagehandler

  %function λfgeneratingenter» ()
    %call «self».exitstack.λpush (&«fgeneratingexit»)
    %cond
      %condif «self».files.λempty ()
	  %mapλ «self».exitstack
	  %overwrite «state» 'idle'
	  %call «self».λfidledenter ()
	  %yield
      %endcondif «self».files.λempty
      %condelse
	    %scope ~subenv «self».files.λpop () «self».env
	      %call «self».outputqueue.λenqueue ({'env' ~subenv})
	    %endscope ~subenv
	    %call «self».outputqueue.λenqueue ({'kick' ❮trigger❯})
	    %mapλ «self».exitstack
	    %overwrite «self».state 'blocked'
	    %call «self».λblockedenter ()
     %endcondelse
   %endcond
  %endfunction λfgeneratingenter

  %function λfgeneratingexit () %endfunction λfgeneratingexit
  %function λfgeneratinghandler ({«self» «message»})
    %switch «message».etag
      %case 'env'
	%overwrite «self».state «message».data
      %endcase 'env'
    %endswitch «message».etag
  %endfunction λfgeneratingmessagehandler

  %function λfblockedenter ()
      %call «self».exitstack.λpush (λblockedexit)
  %endfunction λfblockedenter
  %function λfblockedexit ()
  %endfunction λfblockedexit
  %function λfblockedhandler ({«self» «message»})
      %switch «message».etag
	%case 'env'
	  %overwrite «self».state «message».data
	%endcase 'env'
	%case 'resume'
	  %mapλ «self».exitstack
	  %overwrite «self».state 'generating'
	  %call λfgeneratingenter ()
	%endcase 'resume'
      %endswitch «message».etag
  %endfunction λfblockedmessagehandler

%endmodule foreach_0